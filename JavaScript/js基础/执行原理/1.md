## 执行上下文
执行上下文是 JavaScript 执行一段代码时的运行环境，在执行上下文中存在一个 **变量环境的对象**（Viriable Environment），该对象中保存了变量提升的内容。
1. 当 JavaScript 执行全局代码的时候，会编译全局代码并创建全局执行上下文，而且在整个页面的生存周期内，全局执行上下文只有一份。
2. 当调用一个函数的时候，函数体内的代码会被编译，并创建函数执行上下文，一般情况下，函数执行结束之后，创建的函数执行上下文会被销毁。
3. 当使用 eval 函数的时候，eval 的代码也会被编译，并创建执行上下文。
4. let 声明的变量会存放在词法环境中，var 声明的会存放在变量环境。

## 作用域（scope）
作用域就是变量与函数的可访问范围，即作用域控制着变量和函数的可见性和生命周期。
* 全局作用域
* 函数作用域
* 块级作用域（es6）

## 作用域链
* 词法作用域
词法作用域就是指作用域是由代码中函数声明的位置来决定的，所以词法作用域是静态的作
用域，通过它就能够预测代码在执行过程中如何查找标识符。
* 执行上下文中会有一个 outer，用来记录当前作用域外的上下文中的变量（根据声明位置，而不是执行）。

## 闭包
函数内部返回的函数，用到了外部函数的局部变量，就形成了闭包。（本该销毁的没销毁）

## JavaScript 内存模型
* JavaScript 是一种弱类型（支持隐示类型转换）的、动态（声明的时候不需要指定类型）的语言。
* 在 JavaScript 的执行过程中， 主要有三种类型内存空间，分别是代码空间、栈空间和堆空间。
* 执行上下文存放在栈空间，但变量如果是对象，则会把对象保存在堆空间，栈空间仅保存引用
* 闭包对象（closure(fn)）存放在堆空间中。

## 垃圾回收
* 代际假说
```
第一个是大部分对象在内存中存在的时间很短，简单来说，就是很多对象一经分配内存，
很快就变得不可访问；
第二个是不死的对象，会活得更久。
```
* 垃圾回收器工作流程
```
第一步是标记空间中活动对象和非活动对象。所谓活动对象就是还在使用的对象，非活动对象就是可以进行垃圾回收的对象。
第二步是回收非活动对象所占据的内存。其实就是在所有的标记完成之后，统一清理内存中所有被标记为可回收的对象。
第三步是做内存整理。一般来说，频繁回收对象后，内存中就会存在大量不连续空间，我们把这些不连续的内存空间称为内存碎片。当内存中出现了大量的内存碎片之后，如果需要分配较大连续内存的时候，就有可能出现内存不足的情况。
```
* 副垃圾回收器
副垃圾回收器主要负责新生区的垃圾回收。**新生区中用 Scavenge 算法来处理**。所谓 Scavenge 算法，是把新生区空间对半划分为两个区域，一半是对象区域，一半是空闲区域。
简单来说就是对象区域占满以后，对对象区域的垃圾做标记，标记完成后，副垃圾回收器将存活的对象复制到空白区域并有序的排列起来，然后交换区域，即原来的对象区域变成空白区域，空白区域变成对象区域。
* 主垃圾回收器
新生区经过两次垃圾回收依然还存活的对象，会被移动到老生区中。除了新生区中晋升的对象，一些大的对象会直接被分配到老生区。因此老生区中的对象有两个特点，一个是对象占用空间大，另一个是对象存活时间长。
**主垃圾回收器是采用标记 - 清除（Mark-Sweep）的算法进行垃圾回收的。**
![06.png](https://i.loli.net/2020/03/15/VymbSMBvKgAQuif.png)

首先是标记过程阶段。标记阶段就是从一组根元素开始，递归遍历这组根元素，在这个遍历过程中，能找到的元素称为活动对象，没有到达的元素就可以判断为垃圾数据，添加标记。接下来就是 被标记的垃圾的清除过程。
对一块内存多次执行标记 - 清除算法后，会产生大量不连续的内存碎片。而碎片过多会导致大对象无法分配到足够的连续内存，于是又产生了另外一种算法——标记 - 整理（Mark-Compact），这个标记过程仍然与标记 - 清除算法里的是一样的，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。
* 全停顿
JavaScript 是运行在主线程之上的，一旦执行垃圾回收算法，都需要将正在执行的 JavaScript 脚本暂停下来，待垃圾回收完毕后再恢复脚本执行。

![07.png](https://i.loli.net/2020/03/15/BidDIxPXwfVeNkz.png)

为了降低老生代的垃圾回收而造成的卡顿，V8 将标记过程分为一个个的子标记过程，同时让垃圾回收标记和 JavaScript 应用逻辑交替进行，直到标记阶段完成，我们把这个算法称为增量标记（Incremental Marking）算法。

## 编译器和解释器
1. 在编译型语言的编译过程中，编译器首先会依次对源代码进行词法分析、语法分析，生成抽象语法树（AST），然后是优化代码，最后再生成处理器能够理解的机器码。如果编译成功，将会生成一个可执行的文件。但如果编译过程发生了语法或者其他的错误，那么编译器就会抛出异常，最后的二进制文件也不会生成成功。
2. 在解释型语言的解释过程中，同样解释器也会对源代码进行词法分析、语法分析，并生成抽象语法树（AST），不过它会再基于抽象语法树生成字节码，最后再根据字节码来执行程序、输出结果。
