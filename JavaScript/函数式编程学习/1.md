## curry (柯里化) 和 Function.prototype.bind()
### curry
> 在计算机科学中，柯里化（英语：Currying），又译为卡瑞化或加里化，是把接受多个参数的函数变换成接受一个单一参数（最初函数的第一个参数）的函数，并且返回接受余下的参数而且返回结果的新函数的技术。

> 在直觉上，柯里化声称“如果你固定某些参数，你将得到接受余下参数的一个函数”。所以对于有两个变量的函数 y^{x}，如果固定了 y=2，则得到有一个变量的函数 2^{x}。 —— 维基百科
#### 部分求值
``` javascript
function defadd(a, b) {
    return a + b
}
function add(x) {
    return function(y) {
        return x + y;
    };
};

const increment = add(1);
increment(2);
// 3
```
#### curry
简单实现
``` javascript
function _curry(fn) {
    const len = fn.length;
    function warp (..._arguments) {
        let _arg = _arguments;
        if (_arg.length >= len) { // 判断参数个数
            return fn(..._arg);
        }
        function fnc(...args) {
            _arg = [..._arg, ...args];
            if (_arg.length < len) {
                return fnc;
            } else {
                return fn(..._arg);
            }
        }
        return fnc;
    }
    return warp;
}
```
不同形态
``` javascript
// add(1)(2)()
function simCurry1(fn) {
    const len = fn.length;
    function warp (..._arguments) {
        let _arg = _arguments;
        if (_arg.length >= len) {
            return fn.bind(null, ..._arg); // 判断参数是否足够，且返回值用 bind 绑定
        }
        function fnc(...args) {
            _arg = [..._arg, ...args];
            if (_arg.length < len) {
                return fnc;
            } else {
                return fn.bind(null, ..._arg); // 
            }
        }
        return fnc;
    }
    return warp;
}

// add(1)(2)(3)()  add(1)(2)(3)(4)()
function addInfinity() {
    return [...arguments].reduce((pre, cur) => pre + cur);
}

function simCurry2(fn) {
    function warp (..._arguments) {
        let _arg = _arguments;
        function fnc(...args) {
            _arg = [..._arg, ...args];
            if (args.length > 0) { // 根据有没有参数判断是否执行
                return fnc;
            } else {
                return fn(..._arg);
            }
        }
        return fnc;
    }
    return warp;
}
```
利用 bind
``` javascript
function curry(fn) {
    const len = fn.length;
    return function bindfn() {
        if(arguments.length < len) {
            return bindfn.bind(null, ...arguments); // 关键：保存参数，并在调用时和后面的参数一起传入 bindfn
        } else {
            return fn.call(null, ...arguments);
        }
    }
}
```
### bind
> bind()方法创建一个新的函数，在bind()被调用时，这个新函数的 this 被 bind 的第一个参数指定，其余的参数将作为新函数的参数供调用时使用。 —— MDN

从定义上看，除了我们常用的绑定 this 意外，还有一点：**其余的参数将作为新函数的参数供调用时使用**

``` javascript
function mybind() {
    let [context, ...args] = arguments;
    fToBind = this,
    fBound  = function() {
        // this instanceof fBound === true时,说明返回的fBound被当做new的构造函数调用
        return fToBind.apply(this instanceof fBound
                ? this
                : context,
                [...args, ...arguments]);
    };
    return fBound;
}
```